var DIR = {
    UP: 0,
    RIGHT: 1,
    DOWN: 2,
    LEFT: 3
};
var MAP_STATE = {
    MENU: 0,
    WAIT: 1,
    MOVE: 2,
    SUCCESS: 3,
    FAIL: 4,
    TUT_WAIT: 5
};
var Text = {
    en: {
        tut: ["Swipe to merge the same \ntwo tiles together.", ["Great Job!", "When the two tiles merge,\nthey upgrade!", "Now try to merge the two \ntiles with the boys."], ["Well done!", "Keep merging and try not to \nrun out of moves!", "How far can you go?"]]
    }
};
var VERSION = 60;
var Config = {
    USE_FB: false,
    CHEAT: false,
    SOUND: true,
    GOLDS: [-1, 300, 2e3, 6e3],
    TUT_TILES: [[[1, 1, 0], [3, 1, 0]], [3, 3, 1], [2, 2, 0]],
    TUT_ACTIONS: [DIR.RIGHT, DIR.DOWN]
};
var UserData = {
    isTutDone: false,
    gold: 0,
    curTheme: 0,
    maxLvs: [0, -1, -1, -1],
    maxScores: [0, 0, 0, 0],
    getMaxScore: function() {
        return this.maxScores[this.curTheme]
    },
    setScore: function(score) {
        if (this.maxScores[this.curTheme] < score) {
            this.maxScores[this.curTheme] = score
        }
    },
    setLv: function(lv) {
        if (lv > this.maxLvs[this.curTheme]) {
            this.maxLvs[this.curTheme] = lv
        }
    },
    addGold: function(v) {
        this.gold += v
    },
    useGold: function(v) {
        this.gold -= v
    },
    save: function() {
        var data = {};
        for (var key in this) {
            if (this.hasOwnProperty(key) && typeof this[key] != "function") {
                if (key == "maxLvs" || key == "maxScores") {
                    data[key] = JSON.stringify(this[key])
                } else {
                    data[key] = this[key]
                }
            }
        }
        if (!!window.localStorage) {
            try {
                for (var key in data) {
                    localStorage.setItem(key, data[key])
                }
            } catch (err) {
                console.log("err ")
            }
        }
        if (Config.USE_FB) {
            FBInstant.player.setDataAsync(data).then(function() {
                console.log("setDataAsync saved");
                console.log(data)
            })
        } else {}
        this.print()
    },
    print: function() {},
    setData: function(field, data, defVal) {
        if (data) {
            this[field] = data[field] || defVal
        } else {
            this[field] = localStorage.getItem(field) || defVal
        }
        console.log("load", field, this[field])
    },
    setDataI: function(field, data, defVal) {
        this.setData(field, data, defVal);
        this[field] = parseInt(this[field])
    },
    setDataJson: function(field, data, defVal) {
        var t;
        if (data) {
            t = data[field]
        } else {
            t = localStorage.getItem(field)
        }
        if (t) {
            try {
                this[field] = JSON.parse(t)
            } catch (e) {
                this[field] = defVal
            }
        } else {
            this[field] = defVal
        }
        if (this[field].length) {
            for (var i = 0; i < this[field].length; i++) {
                this[field][i] = parseInt(this[field][i])
            }
        }
        console.log("load", field, this[field])
    },
    _load: function(data) {
        this.setDataJson("maxLvs", data, [0, -1, -1, -1]);
        this.setDataJson("maxScores", data, [0, 0, 0, 0]);
        this.setData("isTutDone", data, false);
        this.setDataI("gold", data, 0);
        this.setData("curTheme", data, 0);
        this.fixLoad()
    },
    fixLoad: function() {
        if (!!window.localStorage) {
            var _maxscore = localStorage.getItem("max_score");
            var _maxlv = localStorage.getItem("max_lv");
            if (_maxscore) {
                _maxscore = parseInt(_maxscore)
            }
            if (_maxlv) {
                _maxlv = parseInt(_maxlv)
            }
            if (_maxscore) {
                if (this.maxScores[0] < _maxscore) {
                    this.maxScores[0] = _maxscore
                }
                if (this.maxLvs[0] < _maxlv) {
                    this.maxLvs[0] = _maxlv
                }
            }
        }
        if (Config.CHEAT) {
            this.isTutDone = false;
            this.gold = 9999
        }
    },
    load: function(callback) {
        console.log("UserData.load");
        this.isLoaded = false;
        var self = this;
        if (Config.USE_FB) {
            FBInstant.player.getDataAsync(["isTutDone", "gold", "curTheme", "maxLvs", "maxScores"]).then(function(data) {
                console.log("FBInstant.player.getDataAsync loaded");
                console.log(data);
                try {
                    self._load(data);
                    callback()
                } catch (err) {
                    console.log(err)
                }
            })
        } else {
            if (!!window.localStorage) {
                this._load(null)
            }
            this.isLoaded = true;
            this.print();
            callback()
        }
    }
};
function tt() {
    (function() {
        var templar;
        function submitFB(callback) {
            var promise = FBInstant.endGameAsync();
            promise.then(function() {
                callback()
            }).catch(function(reason) {
                console.log("endGameAsync error", reason)
            })
        }
        Templar.onLoad = function(callback) {
            console.log("resouces loading done");
            if (Config.USE_FB) {
                console.log("startGameAsync");
                var promise = FBInstant.startGameAsync();
                promise.then(function() {
                    console.log("startGameAsync done");
                    callback();
                    var _m = document.getElementById("gameContainer").getElementsByTagName("canvas")[0];
                    var prev = _m.style.height;
                    setTimeout(function() {
                        console.log("keep " + _m.style.width + " " + _m.style.height);
                        prev = _m.style.height;
                        _m.style.height = ""
                    }, 50);
                    setTimeout(function() {
                        _m.style.height = prev;
                        console.log("resize " + _m.style.width + " " + _m.style.height)
                    }, 100)
                }).catch(function(reason) {
                    console.log("startGameAsync error", reason)
                })
            } else {
                callback()
            }
        }
        ;
        Templar.onGameEnd = function(score, level, callback) {
            console.log("game end, score: " + score + " level: " + level);
            if (Config.USE_FB) {
                var _m = document.getElementById("gameContainer").getElementsByTagName("canvas")[0];
                setTimeout(function() {
                    console.log("screenshot");
                    FBInstant.takeScreenshotAsync().then(function() {
                        console.log("Screenshot taken!")
                    }).catch(function() {
                        console.log("Failed to take screenshot.")
                    })
                }, 1e3);
                FBInstant.setScore(score)
            }
            setTimeout(function() {
                if (Config.USE_FB) {
                    submitFB(callback)
                } else {
                    callback()
                }
            }, 2e3)
        }
        ;
        Templar.onProgress = function(perc) {
            if (Config.USE_FB) {
                FBInstant.setLoadingProgress(perc)
            }
        }
        ;
        function initGame() {
            templar = new Templar.Main("gameContainer",800,1280);
            templar.setLang("en");
            templar.load()
        }
        if (Config.USE_FB) {
            console.log("initializeAsync");
            var prom = FBInstant.initializeAsync();
            prom.then(function() {
                console.log("initializeAsync done");
                UserData.load(initGame)
            }).catch(function(reason) {
                console.log("initializeAsync error", reason)
            })
        } else {
            UserData.load(initGame)
        }
    })()
}
var Util = {
    addU: function(parent, name) {
        var spr = parent.create(0, 0, "ui", name + ".png");
        return spr
    },
    addA: function(parent, name, theme) {
        var spr = parent.create(0, 0, "theme" + (theme == undefined ? UserData.curTheme : theme), name + ".png");
        return spr
    },
    updateFrame: function(obj, frameName, theme) {
        obj.loadTexture("theme" + (theme == undefined ? UserData.curTheme : theme), frameName ? frameName + ".png" : obj.frameName)
    },
    setButtonScale: function(but, scale) {
        but.events.onInputDown.add(function() {
            but.scale.x = scale;
            but.scale.y = scale
        }, this);
        but.events.onInputUp.add(function() {
            but.scale.x = 1;
            but.scale.y = 1
        }, this);
        but.events.onInputOut.add(function() {
            but.scale.x = 1;
            but.scale.y = 1
        }, this)
    },
    setText: function(text, str) {
        text.setText(str)
    },
    log: function(eventName) {
        FB.AppEvents.logEvent(eventName)
    },
    logPlay: function(theme, score, level, golds) {
        FB.AppEvents.logEvent("play", null, {
            theme: theme,
            score: score,
            level: level,
            gold: golds
        })
    }
};
var Templar = {};
Templar.Main = function(container, w, h) {
    Templar.onProgress(10);
    var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    var ratio = height / width;
    var sc = 1;
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        if (ratio > 1.6) {
            ratio = 1.6
        }
    } else {
        ratio = 1.6
    }
    console.log(width + " x " + height);
    Templar.w = w * sc;
    Templar.h = Math.floor(w * sc * ratio);
    this.container = container;
    console.log(Templar.w + " x " + Templar.h)
}
;
Templar.Main.prototype = {
    load: function() {
        Templar.onProgress(20);
        this.game = new Phaser.Game(Templar.w,Templar.h,Phaser.CANVAS,this.container,null,false,false);
        if (this.game.device.desktop) {}
        this.game.preserveDrawingBuffer = true;
        this.game.state.add("Boot", Templar.Boot);
        this.game.state.add("Preloader", Templar.Preloader);
        this.game.state.add("Game", Templar.Game);
        this.game.state.start("Boot")
    },
    setLang: function(lang) {
        Templar.lang = lang
    }
};
Templar.Boot = function(game) {}
;
Templar.Boot.prototype = {
    preload: function() {
        Templar.onProgress(30)
    },
    create: function() {
        this.game.input.maxPointers = 1;
        this.game.stage.disableVisibilityChange = true;
        this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        this.game.scale.pageAlignHorizontally = true;
        this.game.scale.pageAlignVertically = true;
        this.game.scale.setShowAll();
        this.game.scale.refresh();
        this.game.state.start("Preloader");
        Phaser.Canvas.setImageRenderingCrisp(this.game.canvas)
    }
};
Templar.Preloader = function(game) {
    this.ready = false
}
;
Templar.Preloader.prototype = {
    preload: function() {
        for (var i = 0; i < 4; i++) {
            this.load.atlas("theme" + i, "images/theme" + i + ".png", "images/theme" + i + ".js", Phaser.Loader.TEXTURE_ATLAS_JSON_HASH)
        }
        this.load.atlas("ui", "images/ui.png", "images/ui.js", Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);
        this.load.audio("levelupSound", ["sounds/levelup.m4a"]);
        this.load.audio("resultSound", ["sounds/result.m4a"]);
        this.load.audio("bgm", ["sounds/bgm.m4a"]);
        this.load.bitmapFont("f110", "images/fontvs110.png", "images/fontvs110.fnt");
        this.load.bitmapFont("f56", "images/fontvs56.png", "images/fontvs56.fnt");
        this.load.bitmapFont("f46", "images/fontvs46.png", "images/fontvs46.fnt");
        this.game.load.onFileComplete.add(this.fileComplete, this);
        this.game.load.onLoadComplete.add(this.loadComplete, this);
        Templar.onProgress(40);
        this.game.load.start()
    },
    fileComplete: function(progress, cacheKey, success, totalLoaded, totalFiles) {
        var prog = 50 + 20 * (totalLoaded - 1) / totalFiles;
        Templar.onProgress(prog)
    },
    loadComplete: function() {
        Templar.onProgress(70);
        this.game.state.start("Game")
    },
    create: function() {}
};
Templar.Game = function(game) {
    this.sound
}
;
Templar.Game.prototype = {
    bx: 8 * 2.5,
    by: 8 * 2.5,
    _w: 0,
    _h: 0,
    isSoundReady: false,
    init: function() {
        this._w = Templar.w;
        this._h = Templar.h
    },
    create: function() {
        Templar.onProgress(80);
        this.levelupSound = this.game.add.audio("levelupSound");
        this.levelupSound.allowMultiple = true;
        this.resultSound = this.game.add.audio("resultSound");
        this.music = this.game.add.audio("bgm");
        this.sounds = [this.resultSound, this.levelupSound, this.music];
        this.game.sound.setDecodedCallback(this.sounds, this._create, this)
    },
    _create: function() {
        this.isSoundReady = true;
        this.createBg();
        this.map = new Map(this.game);
        this.map.init();
        var self = this;
        this.map.onResult = function(score, lv, gold) {
            if (self.resultSound && Config.SOUND) {
                try {
                    self.resultSound.play()
                } catch (err) {}
            }
            UserData.addGold(gold);
            self.showResult(lv);
            if (Config.SOUND) {
                self.music.pause()
            }
            UserData.save();
            Templar.onGameEnd(score, lv, function() {
                self.showMenu()
            });
            Util.logPlay(UserData.curTheme, score, lv, gold)
        }
        ;
        this.map.onChangeScore = function(score) {
            Util.setText(self.scoreText, score.toString());
            if (score > UserData.getMaxScore()) {
                UserData.setScore(score);
                self.maxScoreText.text = score
            }
        }
        ;
        this.map.onChangeGold = function(gold) {
            Util.setText(self.goldText, gold.toString())
        }
        ;
        this.map.onChangeLevel = function(lv) {
            self.levelSp.frameName = "lavel_" + lv + ".png";
            self.levelSp.visible = true;
            UserData.setLv(lv)
        }
        ;
        this.map.onMerge = function() {
            if (self.levelupSound && Config.SOUND) {
                try {
                    self.levelupSound.play()
                } catch (err) {}
            }
        }
        ;
        this.map.onTutChange = function(tutStep, isTutorial) {
            if (UserData.isTutDone) {
                return
            }
            self.showTutorial()
        }
        ;
        var dark = this.game.add.group();
        Util.addU(dark, "dark");
        dark.x = 0;
        dark.y = 0;
        dark.scale.x = 2;
        dark.scale.y = 2;
        this.createHud();
        this.createMenu();
        this.createHelp();
        this.createOption();
        this.createResult();
        if (Templar.onLoad) {
            Templar.onLoad(function() {
                self.startPlay()
            })
        }
        this.music.loop = true;
        if (Config.SOUND) {
            this.music.play()
        }
    },
    startPlay: function() {
        this.isStarted = true;
        console.log("startPlay");
        this.map.initPlay(!UserData.isTutDone);
        if (!UserData.isTutDone) {
            this.createTutorial();
            this.showTutorial();
            this.helpButton.visible = false;
            this.optionButton.visible = false
        } else {
            this.helpButton.visible = true;
            this.optionButton.visible = true
        }
        this.upKey = this.game.input.keyboard.addKey(Phaser.Keyboard.UP);
        this.upKey.onDown.add(function() {
            this.map.move(DIR.UP)
        }, this);
        this.downKey = this.game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
        this.downKey.onDown.add(function() {
            this.map.move(DIR.DOWN)
        }, this);
        this.leftKey = this.game.input.keyboard.addKey(Phaser.Keyboard.LEFT);
        this.leftKey.onDown.add(function() {
            this.map.move(DIR.LEFT)
        }, this);
        this.rightKey = this.game.input.keyboard.addKey(Phaser.Keyboard.RIGHT);
        this.rightKey.onDown.add(function() {
            this.map.move(DIR.RIGHT)
        }, this);
        if (Config.CHEAT) {
            this.endKey = this.game.input.keyboard.addKey(Phaser.Keyboard.ESC);
            this.endKey.onDown.add(function() {
                this.map._quit()
            }, this);
            this.vKey = this.game.input.keyboard.addKey(Phaser.Keyboard.V);
            this.vKey.onDown.add(function() {
                if (alert) {
                    alert(VERSION)
                }
            }, this)
        }
        this.addSwipe()
    },
    restartPlay: function() {
        console.log("restartPlay");
        this.map.initPlay(false);
        this.resultPopup.visible = false;
        this.scoreResultText.visible = false;
        this.helpButton.visible = true;
        this.optionButton.visible = true;
        this.game.input.disabled = false;
        if (Config.SOUND) {
            this.music.resume()
        }
    },
    createBg: function() {
        this.bg = this.game.add.group();
        this.bgImg = Util.addA(this.bg, "bg");
        this.bgImg.x = 0;
        this.bgImg.y = 0;
        this.stage = Util.addA(this.bg, "stage");
        this.stage.x = (this._w - this.stage.width) / 2;
        this.stage.y = 200 * 2.5
    },
    showOption: function() {
        this.optionButton.visible = false;
        this.helpButton.visible = false;
        this.option.visible = true;
        this.option.scale.set(.5, .5);
        this.game.add.tween(this.option.scale).to({
            x: 1,
            y: 1
        }, 100, Phaser.Easing.Linear.None, true);
        this.game.input.disabled = true
    },
    hideOption: function() {
        this.option.visible = false;
        this.optionButton.visible = true;
        this.helpButton.visible = true;
        this.game.input.disabled = false
    },
    createOptionButton: function(parent, y, label, callback) {
        var bt = this.game.add.sprite(0, 0, "ui", "button_2.png");
        parent.addChild(bt);
        bt.position.set(parent.width / 2, y);
        bt.anchor.set(.5, .5);
        bt.inputEnabled = true;
        bt.scale.set;
        Util.setButtonScale(bt, 1.05);
        var qmark = this.game.add.bitmapText(0, 0, "f46", label, 46);
        qmark.anchor.set(.5, .5);
        bt.addChild(qmark);
        bt.events.onInputUp.add(function(any, pointer, isOver) {
            if (isOver) {
                callback(qmark)
            }
        })
    },
    createOption: function() {
        this.option = this.game.add.group();
        var bg = Util.addU(this.option, "box");
        this.option.x = (this._w - bg.width) / 2;
        this.option.y = (Templar.h - bg.height) / 2;
        var self = this;
        this.createOptionButton(this.option, 50 * 2.5, "MENU", function() {
            self.hideOption();
            self.showMenu()
        });
        this.createOptionButton(this.option, 120 * 2.5, "RESTART", function() {
            self.hideOption();
            self.restartPlay()
        });
        this.createOptionButton(this.option, 190 * 2.5, Config.SOUND ? "SOUND: ON" : "SOUND: OFF", function(label) {
            Config.SOUND = !Config.SOUND;
            label.text = Config.SOUND ? "SOUND: ON" : "SOUND: OFF";
            if (Config.SOUND) {
                self.music.play()
            } else {
                self.music.pause()
            }
        });
        var closeButton = Util.addU(this.option, "box_close");
        closeButton.x = this.option.width - closeButton.width / 2;
        closeButton.y = this.option.height - closeButton.height / 2;
        closeButton.inputEnabled = true;
        closeButton.anchor.set(.5, .5);
        closeButton.events.onInputUp.add(function(any, pt, isOver) {
            if (isOver) {
                this.hideOption()
            }
        }, this);
        Util.setButtonScale(closeButton, 1.1);
        this.option.visible = false
    },
    showHelp: function(theme, onHelpClose, tapClose) {
        this.popup.visible = true;
        this.popup.scale.set(.5, .5);
        this.game.add.tween(this.popup.scale).to({
            x: 1,
            y: 1
        }, 100, Phaser.Easing.Linear.None, true);
        this.helpButton.visible = false;
        this.optionButton.visible = false;
        this.game.input.disabled = true;
        this.isDown = false;
        for (var i = 0; i < this.helpSps.length; i++) {
            Util.updateFrame(this.helpSps[i], undefined, theme)
        }
        this.onHelpClose = onHelpClose;
        if (tapClose) {
            this.game.input.onTap.addOnce(this.helpTap, this)
        }
    },
    helpTap: function() {
        this.popup.visible = false;
        this.onHelpClose()
    },
    createHelp: function() {
        this.popup = this.game.add.group();
        var bg = Util.addU(this.popup, "box");
        this.popup.x = (this._w - bg.width) / 2;
        this.popup.y = (Templar.h - bg.height) / 2;
        var n = 0;
        var _w = 48 * 2.5;
        var _h = 60 * 2.5;
        var sx = (this.popup.width - (4 * _w + 3 * 10)) / 2;
        var sy = (this.popup.height - (3 * _h + 2 * 10)) / 2;
        this.helpSps = [];
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 4; j++) {
                var sp = Util.addA(this.popup, "info_" + (n < 10 ? "0" + n : n));
                sp.x = j * (_w + 10) + sx;
                sp.y = i * (_h + 10) + sy;
                n++;
                if (n <= UserData.maxLv) {} else {}
                this.helpSps.push(sp)
            }
        }
        this.popup.visible = false;
        var closeButton = Util.addU(this.popup, "box_close");
        closeButton.x = this.popup.width - closeButton.width / 2;
        closeButton.y = this.popup.height - closeButton.height / 2;
        closeButton.inputEnabled = true;
        closeButton.anchor.set(.5, .5);
        closeButton.events.onInputUp.add(function(any, pt, isOver) {
            if (isOver) {
                this.popup.visible = false;
                if (this.onHelpClose) {
                    this.onHelpClose()
                }
            }
        }, this);
        Util.setButtonScale(closeButton, 1.1)
    },
    createResult: function() {
        this.resultPopup = this.game.add.group();
        var bg = Util.addU(this.resultPopup, "box");
        bg.height = 50 * 2.5;
        this.resultPopup.x = (this._w - bg.width) / 2;
        this.resultPopup.y = 140 * 2.5;
        this.resultPopup.visible = false;
        this.resultChar = Util.addA(this.resultPopup, "knight_00");
        this.resultChar.anchor.setTo(1, 1);
        this.resultChar.x = this.resultPopup.width / 2 - 50 * 2.5;
        this.resultChar.y = 45 * 2.5;
        this.scoreResultText = this.game.add.bitmapText(Math.floor(this.resultPopup.width / 2), 80, "f110", "0", 110);
        this.scoreResultText.anchor.setTo(0, .5);
        this.scoreResultText.visible = false;
        this.resultPopup.addChild(this.scoreResultText)
    },
    showResult: function(val) {
        var name = "knight_" + (val < 10 ? "0" + val : val);
        Util.updateFrame(this.resultChar, name);
        this.resultPopup.visible = true;
        this.scoreResultText.visible = true;
        Util.setText(this.scoreResultText, this.map.score);
        this.helpButton.visible = false;
        this.optionButton.visible = false;
        this.game.input.disabled = true;
        this.isDown = false;
        this.resultPopup.x = -Templar.w;
        this.game.add.tween(this.resultPopup).to({
            x: 0
        }, 200, Phaser.Easing.Linear.None, true)
    },
    onScrollStart: function() {
        var startY = this.game.input.y;
        if (startY <= this.menuBottom && startY >= this.menuTop) {
            this.startX = this.game.input.x;
            this.pressedDown = true
        }
    },
    onScrollEnd: function() {
        this.pressedDown = false
    },
    onScrollUpdate: function(any, x, y) {
        if (!this.pressedDown)
            return;
        var delta = x - this.startX;
        this.startX = x;
        var _x = this.menuSlide.x + delta;
        if (this.scrollTw && this.scrollTw.isRunning) {
            return
        }
        if (_x > 10 * 2.5) {
            this.scrollTw = this.game.add.tween(this.menuSlide).to({
                x: 0
            }, 300, Phaser.Easing.Linear.None, true)
        } else if (_x < -264 * 2.5) {
            this.scrollTw = this.game.add.tween(this.menuSlide).to({
                x: -244 * 2.5
            }, 300, Phaser.Easing.Linear.None, true)
        } else {
            this.menuSlide.x = _x
        }
    },
    onStartClick: function() {
        if (UserData.maxLvs[this.selectedTheme] == -1) {
            if (Config.GOLDS[this.selectedTheme] <= UserData.gold) {
                UserData.useGold(Config.GOLDS[this.selectedTheme]);
                UserData.maxLvs[this.selectedTheme] = 0;
                this.onThemeChange(this.selectedTheme);
                console.log("buy done");
                Util.log("buy_theme_" + this.selectedTheme);
                UserData.save()
            } else {
                var box = this.game.add.group();
                var black = Util.addU(box, "black");
                black.width = Templar.w;
                black.height = 60;
                black.alpha = .4;
                black.anchor.set(0, .5);
                box.position.set(0, this.menu.height / 2);
                var msgtext = this.game.add.bitmapText(Templar.w / 2, 0, "f46", "not enough golds", 46);
                msgtext.anchor.set(.5, .5);
                box.addChild(msgtext);
                this.menu.addChild(box);
                var tw = this.game.add.tween(box).to({
                    alpha: 0
                }, 700, Phaser.Easing.Linear.None, true, 500);
                tw.onComplete.add(function() {
                    this.menu.removeChild(box);
                    msgtext.destroy()
                }, this);
                console.log("lack gold")
            }
        } else {
            UserData.curTheme = this.selectedTheme;
            this.hideMenu();
            if (this.isStarted) {
                this.restartPlay()
            } else {
                this.startPlay()
            }
        }
    },
    createMenu: function() {
        this.menu = this.game.add.group();
        var bg = Util.addU(this.menu, "box");
        this.menuSlide = this.game.add.group();
        this.menu.addChild(this.menuSlide);
        bg.inputEnabled = true;
        this.menu.x = 0;
        this.menu.y = (Templar.h - bg.height) / 2;
        this.menuTop = this.menu.y;
        this.menuBottom = this.menu.y + bg.height;
        this.menu.visible = false;
        this.stories = [];
        var self = this;
        for (var i = 0; i < 4; i++) {
            var story = Util.addU(this.menuSlide, "story_" + i);
            story.position.set((40 + 130 * i) * 2.5, 2 * 2.5);
            story.inputEnabled = true;
            story._theme = i;
            story.events.onInputUp.add(function(any, pointer, isOver) {
                if (isOver && !this.pressedDown) {
                    self.onThemeChange(any._theme)
                }
            });
            var grayscale = Util.addU(this.menuSlide, "black");
            grayscale.position = story.position;
            grayscale.width = story.width;
            grayscale.height = story.height;
            grayscale.blendMode = 14;
            story._gray = grayscale;
            this.stories.push(story)
        }
        this.selectStory = Util.addU(this.menuSlide, "select_story");
        var bt = this.game.add.sprite(0, 0, "ui", "button_1.png");
        this.selectStory.addChild(bt);
        bt.position.set(this.selectStory.width / 2, 243 * 2.5);
        bt.anchor.set(.5, .5);
        bt.inputEnabled = true;
        bt.events.onInputUp.add(function(any, pointer, isOver) {
            if (isOver) {
                self.hideMenu();
                self.showHelp(this.selectedTheme, function() {
                    self.showMenu()
                })
            }
        });
        Util.setButtonScale(bt, 1.05);
        var qmark = this.game.add.bitmapText(0, 0, "f46", "?", 46);
        qmark.anchor.set(.5, .5);
        bt.addChild(qmark);
        this.playButton = Util.addU(this.menu, "play");
        this.playButton.x = this._w / 2;
        this.playButton.y = bg.height + 60 * 2.5;
        this.playButton.inputEnabled = true;
        this.playButton.anchor.set(.5, .5);
        this.playButton.events.onInputUp.add(function(any, pt, isOver) {
            if (isOver) {
                self.onStartClick()
            }
        });
        Util.setButtonScale(this.playButton, 1.1);
        this.goldSpr = Util.addU(this.menu, "icon_gold");
        this.goldSpr.x = this._w / 2 - 20 * 2.5;
        this.goldSpr.y = bg.height + 20 * 2.5;
        this.goldSpr.anchor.set(.5, .5);
        this.goldMenuText = this.game.add.bitmapText(this.goldSpr.x + 20 * 2.5, this.goldSpr.y, "f46", "", 46);
        this.goldMenuText.anchor.setTo(0, .5);
        this.menu.addChild(this.goldMenuText)
    },
    onThemeChange: function(theme) {
        if (theme != undefined) {
            UserData.curTheme = theme
        }
        this.selectedTheme = theme;
        var story = this.stories[theme];
        this.selectStory.position.set(story.x - 4 * 2.5, story.y - 4 * 2.5);
        for (var i = 0; i < 4; i++) {
            this.stories[i]._gray.visible = UserData.maxLvs[i] == -1
        }
        Util.updateFrame(this.bgImg, "bg");
        Util.updateFrame(this.stage, "stage");
        Util.updateFrame(this.title, "title");
        if (UserData.maxLvs[theme] == -1) {
            this.playButton.frameName = "buy.png";
            this.goldSpr.visible = true;
            this.goldMenuText.visible = true;
            this.goldMenuText.setText(Config.GOLDS[theme].toString())
        } else {
            this.playButton.frameName = "play.png";
            this.goldSpr.visible = false;
            this.goldMenuText.visible = false
        }
    },
    showMenu: function() {
        if (this.menu.visible) {
            return
        }
        this.menu.visible = true;
        this.pressedDown = false;
        this.resultPopup.visible = false;
        this.scoreResultText.visible = false;
        this.levelSp.visible = false;
        this.helpButton.visible = false;
        this.optionButton.visible = false;
        this.game.input.onDown.add(this.onScrollStart, this);
        this.game.input.onUp.add(this.onScrollEnd, this);
        this.game.input.addMoveCallback(this.onScrollUpdate, this);
        Util.setText(this.goldText, UserData.gold.toString());
        if (UserData.curTheme == 0 || UserData.curTheme == 1) {
            this.menuSlide.x = 0
        } else {
            this.menuSlide.x = -244 * 2.5
        }
        this.onThemeChange(UserData.curTheme)
    },
    hideMenu: function() {
        if (!this.menu.visible) {
            return
        }
        this.menu.visible = false;
        this.game.input.onDown.remove(this.onScrollStart, this);
        this.game.input.onUp.remove(this.onScrollEnd, this);
        this.game.input.deleteMoveCallback(this.onScrollUpdate, this)
    },
    createHud: function() {
        console.log("createHud", this._w);
        this.hud = this.game.add.group();
        this.title = Util.addA(this.hud, "title");
        this.title.x = this.bx;
        this.title.y = this.by;
        var scoreBack = Util.addU(this.hud, "button");
        scoreBack.x = this._w - 2 * scoreBack.width - 2 * this.bx;
        scoreBack.y = this.by;
        this.scoreLabelText = this.game.add.bitmapText(Math.floor(scoreBack.x + scoreBack.width / 2), Math.floor(scoreBack.y + 7 * 2.5), "f46", "SCORE", 46);
        this.scoreLabelText.anchor.setTo(.5, 0);
        this.scoreLabelText.tint = 6316128;
        this.scoreText = this.game.add.bitmapText(Math.floor(scoreBack.x + scoreBack.width / 2), Math.floor(scoreBack.y + 25 * 2.5), "f56", "0", 56);
        this.scoreText.anchor.setTo(.5, 0);
        var maxScoreBack = Util.addU(this.hud, "button");
        maxScoreBack.x = this._w - maxScoreBack.width - this.bx;
        maxScoreBack.y = this.by;
        this.maxSoreLabelText = this.game.add.bitmapText(Math.floor(maxScoreBack.x + maxScoreBack.width / 2), Math.floor(maxScoreBack.y + 7 * 2.5), "f46", "BEST", 46);
        this.maxSoreLabelText.anchor.setTo(.5, 0);
        this.maxSoreLabelText.tint = this.scoreLabelText.tint;
        this.maxScoreText = this.game.add.bitmapText(Math.floor(maxScoreBack.x + maxScoreBack.width / 2), Math.floor(maxScoreBack.y + 25 * 2.5), "f56", UserData.getMaxScore().toString(), 56);
        this.maxScoreText.anchor.setTo(.5, 0);
        var goldBack = Util.addU(this.hud, "button_gold");
        goldBack.x = this._w - goldBack.width - this.bx;
        goldBack.y = this.by + scoreBack.height + 4;
        this.goldText = this.game.add.bitmapText(Math.floor(goldBack.x + goldBack.width * 11 / 12), Math.floor(goldBack.y + goldBack.height / 2 + 4), "f46", UserData.gold.toString(), 46);
        this.goldText.maxW;
        this.goldText.anchor.setTo(1, .5);
        var self = this;
        this.helpButton = Util.addU(this.hud, "button_help");
        this.helpButton.x = this._w - this.helpButton.width / 2 - this.bx;
        this.helpButton.y = Templar.h - this.helpButton.height / 2 - this.by;
        this.helpButton.inputEnabled = true;
        this.helpButton.anchor.set(.5, .5);
        this.helpButton.events.onInputUp.add(function(any, pt, isOver) {
            if (isOver) {
                this.showHelp(UserData.curTheme, function() {
                    self.helpButton.visible = true;
                    self.optionButton.visible = true;
                    self.game.input.disabled = false
                })
            }
        }, this);
        Util.setButtonScale(this.helpButton, 1.1);
        this.optionButton = Util.addU(this.hud, "button_option");
        this.optionButton.x = this.optionButton.width / 2 + this.bx;
        this.optionButton.y = Templar.h - this.optionButton.height / 2 - this.by;
        this.optionButton.inputEnabled = true;
        this.optionButton.anchor.set(.5, .5);
        this.optionButton.events.onInputUp.add(function(any, pt, isOver) {
            if (isOver) {
                self.showOption()
            }
        }, this);
        Util.setButtonScale(this.optionButton, 1.1);
        this.levelSp = Util.addU(this.hud, "lavel_0");
        this.levelSp.x = (this._w - this.levelSp.width) / 2;
        this.levelSp.y = 250
    },
    createTutorial: function() {
        this.tutorial = this.game.add.group();
        this.hand = Util.addU(this.tutorial, "finger");
        this.hand.visible = false;
        this.tutBox = this.game.add.group();
        var black = Util.addU(this.tutBox, "black");
        black.width = Templar.w;
        black.height = 50 * 2.5;
        black.alpha = .4;
        var style = {
            font: "40px Arial",
            fontWeight: "bold",
            fill: "#ffffff",
            align: "center"
        };
        this.tutText = new Phaser.Text(this.game,Templar.w / 2,black.height / 2,"",style);
        this.tutText.anchor.setTo(.5, .5);
        this.tutBox.addChild(this.tutText);
        this.tutBox.visible = false;
        this.tutBox.y = Templar.h / 2 - 120 * 2.5
    },
    showTutorial: function() {
        this.hand.visible = false;
        this.tutBox.visible = false;
        this.map.setState(MAP_STATE.TUT_WAIT);
        setTimeout(this._showTutorial.bind(this), 1e3)
    },
    _showTutorial: function() {
        this.tutSteps[this.map.tutStep].call(this)
    },
    tutSteps: [function() {
        this.showTutText(0);
        this.showHand(Config.TUT_ACTIONS[0])
    }
    , function() {
        var self = this;
        this.showTutText(1, 0);
        setTimeout(function() {
            self.showTutText(1, 1)
        }, 2e3);
        setTimeout(function() {
            self.showTutText(1, 2);
            self.showHand(Config.TUT_ACTIONS[1])
        }, 4e3)
    }
    , function() {
        this.map.setState(MAP_STATE.TUT_WAIT);
        var self = this;
        this.showTutText(2, 0);
        setTimeout(function() {
            self.showTutText(2, 1)
        }, 2e3);
        setTimeout(function() {
            self.tutBox.visible = false;
            self.showHelp(0, function() {
                self.helpButton.visible = true;
                self.optionButton.visible = true;
                self.game.input.disabled = false;
                self.tutBox.visible = false;
                self.map.setState(MAP_STATE.WAIT);
                self.game.input.onTap.remove(self.helpTap, self)
            }, true)
        }, 4e3);
        setTimeout(function() {
            if (self.popup.visible) {
                self.showTutText(2, 2);
                self.map.setState(MAP_STATE.WAIT)
            }
        }, 5e3)
    }
    ],
    showTutText: function(idx, idx2) {
        var tut = Text["en"]["tut"];
        if (tut) {
            this.tutBox.visible = true;
            var text;
            if (idx2 != undefined && tut[idx][idx2]) {
                text = tut[idx][idx2]
            } else {
                text = tut[idx]
            }
            Util.setText(this.tutText, text);
            this.tutText.scale.y = .1;
            this.game.add.tween(this.tutText.scale).to({
                y: 1
            }, 100, Phaser.Easing.Back.InOut, true)
        }
    },
    showHand: function(dir) {
        if (this.handTween) {
            this.game.tweens.remove(this.handTween)
        } else {}
        this.hand.visible = true;
        var sx = sy = ex = ey = 0;
        var _x1 = 60 * 2.5;
        var _x2 = this._w - 80 * 2.5;
        var _y1 = 200 * 2.5;
        var _y2 = 310 * 2.5;
        if (dir == DIR.RIGHT) {
            sx = _x1;
            sy = _y2;
            ex = _x2;
            ey = _y1
        } else if (dir == DIR.LEFT) {
            sx = _x2;
            sy = _y1;
            ex = _x1;
            ey = _y2
        } else if (dir == DIR.UP) {
            sx = _x2;
            sy = _y2;
            ex = _x1;
            ey = _y1
        } else if (dir == DIR.DOWN) {
            sx = _x1;
            sy = _y1;
            ex = _x2;
            ey = _y2
        }
        this.hand.x = sx;
        this.hand.y = sy;
        var tw = this.game.add.tween(this.hand).to({
            x: ex,
            y: ey
        }, 1 * 800, Phaser.Easing.Linear.None, true);
        tw.repeat(10, 1e3);
        this.handTween = tw;
        this.map.setState(MAP_STATE.WAIT)
    },
    render: function() {},
    update: function() {
        if (!this.isSoundReady) {
            return
        }
        if (this.map.state == MAP_STATE.MENU) {
            return
        }
        if (this.isPopup()) {
            return
        }
        if (this.map) {
            this.map.update()
        }
    },
    isPopup: function() {
        return this.popup.visible || this.resultPopup.visible || this.menu.visible || this.option.visible
    },
    addSwipe: function() {
        this.startPoint = {};
        this.endPoint = {};
        this.isDown = false;
        var minimum = {
            duration: 75,
            x: 10,
            y: 8
        };
        var self = this;
        this.game.input.onDown.add(function(pointer) {
            if (self.isPopup()) {
                return
            }
            self.startPoint.x = pointer.clientX;
            self.startPoint.y = pointer.clientY;
            self.isDown = true
        }, this);
        this.game.input.onUp.add(function(pointer) {
            if (self.isPopup()) {
                return
            }
            if (!self.isDown) {
                return
            }
            var eventDuration = self.game.input.activePointer.duration;
            {
                self.endPoint.x = pointer.clientX;
                self.endPoint.y = pointer.clientY;
                var diffx = self.endPoint.x - self.startPoint.x;
                var diffy = -(self.endPoint.y - self.startPoint.y);
                if (diffx > minimum.x) {
                    if (diffy > minimum.y) {
                        self.map.move(DIR.RIGHT);
                        self.isDown = false
                    } else if (diffy < -minimum.y) {
                        self.map.move(DIR.DOWN);
                        self.isDown = false
                    }
                } else if (diffx < -minimum.x) {
                    if (diffy > minimum.y) {
                        self.map.move(DIR.UP);
                        self.isDown = false
                    } else if (diffy < -minimum.y) {
                        self.map.move(DIR.LEFT);
                        self.isDown = false
                    }
                }
            }
        }, this)
    }
};
var Map = function(game) {
    this.game = game;
    this.MAX_NUM = 12;
    this.WIDTH = 4;
    this.HEIGHT = 4;
    this.score = 0;
    this.gold = 0;
    this.level = 0;
    this.cells = [];
    this.state = MAP_STATE.MENU;
    this.mapG = this.game.add.group();
    this.mapE = this.game.add.group();
    this.tutStep = 0
};
Map.prototype = {
    setState: function(s) {
        this.state = s
    },
    clearMap: function() {
        for (var y = 0; y < this.HEIGHT; y++) {
            for (var x = 0; x < this.WIDTH; x++) {
                var tile = this.cells[y][x];
                tile.setVal(-1, true);
                tile.goldAnim = null;
                tile.goldVal = 0
            }
        }
        for (var i = 0; i < this.goldanims.length; i++) {
            this.goldanims[i].visible = false
        }
    },
    init: function() {
        this.cells = [];
        for (var y = 0; y < this.HEIGHT; y++) {
            this.cells[y] = [];
            for (var x = 0; x < this.WIDTH; x++) {
                var tile = new Tile;
                tile.init(this, x, y, -1);
                this.cells[y][x] = tile
            }
        }
        var lst = [];
        var cnt = 16;
        for (var i = 0; i <= cnt; i++) {
            lst.push("fx_" + (i < 10 ? "0" + i : i) + ".png")
        }
        this.effects = [];
        for (var i = 0; i < 6; i++) {
            var eff = Util.addA(this.mapE, "fx_00", 0);
            eff.anchor.setTo(.5, .5);
            eff.x = 0;
            eff.y = 0;
            var anim = eff.animations.add("effect", lst);
            anim.onComplete.add(function(sprite) {
                sprite.visible = false
            }, this);
            eff.visible = false;
            this.effects.push(eff)
        }
        var lst1 = [];
        for (var i = 0; i <= 7; i++) {
            lst1.push("item_gold_00_0" + i + ".png")
        }
        var lst2 = [];
        for (var i = 0; i <= 7; i++) {
            lst2.push("item_gold_01_0" + i + ".png")
        }
        var lst3 = [];
        for (var i = 0; i <= 7; i++) {
            lst3.push("item_gold_02_0" + i + ".png")
        }
        this.goldanims = [];
        for (var i = 0; i < 12; i++) {
            var eff = Util.addU(this.mapE, "item_gold_00_00", 0);
            eff.anchor.setTo(.5, .5);
            eff.x = 0;
            eff.y = 0;
            var anim1 = eff.animations.add("gold_1", lst1);
            anim1.onComplete.add(function(sprite) {
                sprite.visible = false
            }, this);
            var anim2 = eff.animations.add("gold_2", lst2);
            anim2.onComplete.add(function(sprite) {
                sprite.visible = false
            }, this);
            var anim3 = eff.animations.add("gold_3", lst3);
            anim2.onComplete.add(function(sprite) {
                sprite.visible = false
            }, this);
            eff.visible = false;
            this.goldanims.push(eff)
        }
    },
    showMergeFx: function(tile) {
        for (var i in this.effects) {
            var ef = this.effects[i];
            if (!ef.visible) {
                ef.x = tile.spr.x;
                ef.y = tile.spr.y - 50 * 2.5;
                ef.visible = true;
                ef.animations.play("effect", 40, false);
                break
            }
        }
    },
    showGoldFx: function(tile, val) {
        for (var i in this.goldanims) {
            var ef = this.goldanims[i];
            if (!ef.visible) {
                ef.x = tile.spr.x;
                ef.y = tile.spr.y + Tile.GOLD_LOCAL_Y;
                ef.visible = true;
                ef.animations.play("gold_" + val, 10, true);
                tile.goldAnim = ef;
                tile.goldVal = val;
                break
            }
        }
    },
    initPlay: function(isTutorial) {
        this.isTutorial = isTutorial;
        this.clearMap();
        this.score = 0;
        this.level = 0;
        this.gold = 0;
        if (this.isTutorial) {
            this.createTutTile()
        } else {
            this.setRandTile();
            this.setRandTile()
        }
        if (this.onChangeScore) {
            this.onChangeScore(this.score)
        }
        if (this.onChangeGold) {
            this.onChangeGold(this.gold)
        }
        this.updateLevel(true);
        this.setState(MAP_STATE.WAIT)
    },
    createTutTile: function() {
        var t = Config.TUT_TILES[this.tutStep];
        if (this.tutStep == 0) {
            this.cells[t[0][1]][t[0][0]].setVal(t[0][2], true, true);
            this.cells[t[1][1]][t[1][0]].setVal(t[1][2], true, true)
        } else {
            this.cells[t[1]][t[0]].setVal(t[2], true, true)
        }
    },
    getTile: function(x, y) {
        if (x < 0 || x >= this.WIDTH || y < 0 || y >= this.HEIGHT) {
            return null
        }
        return this.cells[y][x]
    },
    setTile: function(x, y, val) {
        var tile = this.cells[y][x];
        tile.setVal(val, true, false);
        this.addGoldIcon(tile)
    },
    getAvail: function() {
        var tiles = [];
        for (var y = 0; y < this.HEIGHT; y++) {
            for (var x = 0; x < this.WIDTH; x++) {
                var tile = this.cells[y][x];
                if (tile.val == -1) {
                    tiles.push(tile)
                }
            }
        }
        var size = tiles.length;
        if (size == 0) {
            return null
        } else {
            return tiles[Math.floor(Math.random() * size)]
        }
    },
    setRandTile: function() {
        var tile = this.getAvail();
        if (tile != null) {
            if (Math.random() < .9) {
                tile.setVal(0, true, true)
            } else {
                tile.setVal(1, true, true)
            }
        }
    },
    moveTile: function(tile, x, y) {
        var toTile = this.cells[y][x];
        toTile.setVal(tile.val, true, false);
        if (tile.goldAnim) {
            toTile.goldAnim = tile.goldAnim;
            toTile.goldVal = tile.goldVal
        }
        toTile.moveTo(tile.x, tile.y, x, y);
        tile.setVal(-1, true, true);
        tile.goldAnim = null;
        tile.goldVal = 0;
        return Math.abs(tile.x - x) + Math.abs(tile.y - y)
    },
    mergeTile: function(from, to) {
        from.setVal(-1, false);
        var newVal = to.val + 1;
        to.setVal(newVal, false);
        var anim1 = null;
        var anim2 = null;
        var goldVal1 = 0;
        var goldVal2 = 0;
        if (to.goldAnim) {
            anim2 = to.goldAnim;
            goldVal2 = to.goldVal
        }
        if (from.goldAnim) {
            anim1 = from.goldAnim;
            goldVal1 = from.goldVal
        }
        to.goldAnim = null;
        to.goldVal = 0;
        var self = this;
        from.moveTo(from.x, from.y, to.x, to.y, function() {
            from.updateSpr(false);
            to.updateSpr(false);
            var goldRemoved = false;
            if (anim1 != null) {
                self.removeGoldIcon(anim1, goldVal1);
                goldRemoved = true
            }
            if (anim2 != null) {
                self.removeGoldIcon(anim2, goldVal2);
                goldRemoved = true
            }
            if (!goldRemoved) {
                self.addGoldIcon(to)
            }
            self.showMergeFx(to);
            if (self.onMerge) {
                self.onMerge()
            }
            self.addScore(to.getScore());
            self.updateLevel()
        });
        if (anim1 != null) {
            from.goldAnim = null;
            from.goldVal = 0
        }
        to.isJustMerged = true;
        return Math.abs(from.x - to.x) + Math.abs(from.y - to.y)
    },
    move: function(dir) {
        if (this.state != MAP_STATE.WAIT) {
            return
        }
        if (this.isTutorial) {
            if (Config.TUT_ACTIONS[this.tutStep] == dir) {
                this.tutStep += 1;
                if (this.tutStep >= Config.TUT_ACTIONS.length) {
                    this.isTutorial = false
                }
                if (this.onTutChange) {
                    this.onTutChange(this.tutStep, this.isTutorial)
                }
            } else {
                return
            }
        }
        var dx = 1;
        var dy = 1;
        var startX = 0;
        var endX = this.WIDTH;
        var startY = 0;
        var endY = this.HEIGHT;
        if (dir == DIR.UP) {} else if (dir == DIR.DOWN) {
            dy = -1;
            startY = this.HEIGHT - 1;
            endY = -1
        } else if (dir == DIR.RIGHT) {
            dx = -1;
            startX = this.WIDTH - 1;
            endX = -1
        } else if (dir == DIR.LEFT) {}
        for (var y in this.cells) {
            for (var x in this.cells[y]) {
                this.cells[y][x].prepare()
            }
        }
        var moved = false;
        var maxDist = 0;
        for (var x = startX; x != endX; x += dx) {
            for (var y = startY; y != endY; y += dy) {
                var tile = this.getTile(x, y);
                if (tile.val != -1) {
                    var near = this.findNear(tile, dir);
                    if (near != null) {
                        if (near.val == tile.val) {
                            var dist = this.mergeTile(tile, near);
                            if (dist > maxDist) {
                                maxDist = dist
                            }
                        } else {
                            var dist = this.moveTile(tile, near.x, near.y);
                            if (dist > maxDist) {
                                maxDist = dist
                            }
                        }
                        moved = true
                    }
                }
            }
        }
        if (moved) {
            this.setState(MAP_STATE.MOVE);
            this.game.time.events.add(Phaser.Timer.SECOND * maxDist * .2, this.createNew, this)
        }
    },
    findNear: function(tile, dir) {
        var near = null;
        if (dir == DIR.DOWN) {
            for (var y = tile.y + 1; y < this.HEIGHT; y++) {
                var t = this.getTile(tile.x, y);
                if (tile.val == t.val && !t.isJustMerged) {
                    near = t;
                    break
                } else if (t.val == -1) {
                    near = t
                } else {
                    break
                }
            }
        } else if (dir == DIR.UP) {
            for (var y = tile.y - 1; y >= 0; y--) {
                var t = this.getTile(tile.x, y);
                if (tile.val == t.val && !t.isJustMerged) {
                    near = t;
                    break
                } else if (t.val == -1) {
                    near = t
                } else {
                    break
                }
            }
        } else if (dir == DIR.LEFT) {
            for (var x = tile.x - 1; x >= 0; x--) {
                var t = this.getTile(x, tile.y);
                if (tile.val == t.val && !t.isJustMerged) {
                    near = t;
                    break
                } else if (t.val == -1) {
                    near = t
                } else {
                    break
                }
            }
        } else if (dir == DIR.RIGHT) {
            for (var x = tile.x + 1; x < this.WIDTH; x++) {
                var t = this.getTile(x, tile.y);
                if (tile.val == t.val && !t.isJustMerged) {
                    near = t;
                    break
                } else if (t.val == -1) {
                    near = t
                } else {
                    break
                }
            }
        }
        return near
    },
    createNew: function() {
        if (this.isTutorial) {
            this.createTutTile();
            this.setState(MAP_STATE.TUT_WAIT)
        } else {
            this.setRandTile();
            this.setState(MAP_STATE.WAIT);
            if (this.isMax()) {
                this.setState(MAP_STATE.SUCCESS);
                if (this.onResult) {
                    this.onResult(this.score, this.level, this.gold)
                }
            } else if (!this.isMoveAvailable()) {
                this.setState(MAP_STATE.FAIL);
                if (this.onResult) {
                    this.onResult(this.score, this.level, this.gold)
                }
            }
        }
    },
    _quit: function() {
        if (this.state == MAP_STATE.FAIL) {
            return
        }
        this.setState(MAP_STATE.FAIL);
        if (this.onResult) {
            this.onResult(this.score, this.level, this.gold)
        }
    },
    isMax: function() {
        return this.level == this.MAX_NUM
    },
    isMoveAvailable: function() {
        for (var y = 0; y < this.HEIGHT; y++) {
            for (var x = 0; x < this.WIDTH; x++) {
                var tile = this.cells[y][x];
                if (tile.val == -1) {
                    return true
                }
                var right = this.getTile(x + 1, y);
                if (right != null && tile.val == right.val) {
                    return true
                }
                var down = this.getTile(x, y + 1);
                if (down != null && tile.val == down.val) {
                    return true
                }
            }
        }
        return false
    },
    updateLevel: function(force) {
        var lv = 0;
        for (var y = 0; y < this.HEIGHT; y++) {
            for (var x = 0; x < this.WIDTH; x++) {
                var tile = this.cells[y][x];
                if (lv < tile.val) {
                    lv = tile.val
                }
            }
        }
        if (force || lv > this.level) {
            this.level = lv;
            this.onChangeLevel(this.level)
        }
    },
    getGoldVal: function(tile) {
        var rval = Math.floor(Math.random() * 100);
        var val = 1;
        if (tile.val <= 0) {
            return 0
        } else if (tile.val <= 5) {
            if (rval < 70) {
                return 0
            }
            val = 1
        } else if (tile.val >= 6 && tile.val <= 9) {
            if (rval < 40) {
                return 0
            } else if (rval < 50) {
                val = 1
            } else if (rval < 90) {
                val = 2
            } else {
                val = 3
            }
        } else {
            if (rval < 30) {
                return 0
            } else if (rval < 70) {
                val = 2
            } else {
                val = 3
            }
        }
        return val
    },
    addGoldIcon: function(tile) {
        var val = this.getGoldVal(tile);
        if (val > 0) {
            this.showGoldFx(tile, val)
        }
    },
    removeGoldIcon: function(anim, goldVal) {
        if (anim) {
            var tw = this.game.add.tween(anim).to({
                y: anim.y - 30 * 2.5
            }, 300, Phaser.Easing.Linear.None, true);
            tw.onComplete.add(function() {
                anim.visible = false
            });
            var amount = 1;
            if (goldVal == 2) {
                amount = 3
            } else if (goldVal == 3) {
                amount = 5
            }
            this.addGold(amount)
        }
    },
    addGold: function(val) {
        this.gold += val;
        this.onChangeGold(this.gold)
    },
    addScore: function(v) {
        this.score += v;
        this.onChangeScore(this.score)
    },
    update: function() {
        this.mapG.sort("y", Phaser.Group.SORT_ASCENDING)
    }
};
var Tile = function() {
    this.difx = 50 * 2.5 * 4 / 5;
    this.dify = 22 * 2.5;
    this.startx = 50 * 2.5 * 4 / 5;
    this.starty = (326 - 25) * 2.5;
    this.isJustMerged = false;
    this.goldAnim = null;
    this.goldVal = 0
};
Tile.GOLD_LOCAL_Y = -65 * 2.5;
Tile.prototype = {
    init: function(map, x, y, val) {
        this.map = map;
        this.x = x;
        this.y = y;
        this.val = val;
        this.spr = null
    },
    setVal: function(val, isUpdateSpr, showAlphaTween) {
        this.val = val;
        if (isUpdateSpr) {
            this.updateSpr(showAlphaTween)
        }
    },
    prepare: function() {
        this.isJustMerged = false
    },
    getScore: function() {
        if (this.val == -1 || this.val == 0) {
            return 0
        } else {
            return Math.pow(2, this.val)
        }
    },
    updateSpr: function(showAlphaTween) {
        if (this.val == -1) {
            if (this.spr) {
                this.spr.visible = false
            }
        } else {
            var name = "knight_" + (this.val < 10 ? "0" + this.val : this.val);
            if (this.spr == null) {
                this.spr = Util.addA(this.map.mapG, name);
                this.spr.anchor.setTo(.5, 1)
            } else {
                if (this.spr.key == "theme" + UserData.curTheme) {
                    this.spr.frameName = name + ".png"
                } else {
                    this.spr.loadTexture("theme" + UserData.curTheme, name + ".png")
                }
            }
            this.spr.visible = true;
            this.updateLoc();
            if (showAlphaTween && this.spr) {
                this.spr.alpha = 0;
                this.map.game.add.tween(this.spr).to({
                    alpha: 1
                }, 200, "Linear", true)
            }
        }
    },
    updateLoc: function() {
        if (this.spr == null) {
            return
        }
        this.spr.x = this.startx + this.difx * (this.x + this.y);
        this.spr.y = this.starty - this.dify * (this.x - this.y)
    },
    moveTo: function(x1, y1, x2, y2, onMerge) {
        var px1 = this.startx + this.difx * (x1 + y1);
        var py1 = this.starty - this.dify * (x1 - y1);
        this.spr.x = px1;
        this.spr.y = py1;
        var px = this.startx + this.difx * (x2 + y2);
        var py = this.starty - this.dify * (x2 - y2);
        var tm = .1 * 1e3;
        if (this.goldAnim) {
            this.goldAnim.position.set(px1, py1 + Tile.GOLD_LOCAL_Y);
            this.map.game.add.tween(this.goldAnim).to({
                x: px,
                y: py + Tile.GOLD_LOCAL_Y
            }, tm, Phaser.Easing.Linear.None, true)
        }
        var tw = this.map.game.add.tween(this.spr);
        tw.to({
            x: px,
            y: py
        }, tm, Phaser.Easing.Linear.None);
        tw.onComplete.add(function() {
            if (onMerge) {
                onMerge()
            }
        }, this);
        tw.start()
    }
};
