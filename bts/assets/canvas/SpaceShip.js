
// -- user code here --

/* --- start generated code --- */

// Generated by  1.4.4 (Phaser v2.6.2)


/**
 * SpaceShip.
 * @param aGame {Phaser.Game} A reference to the currently running game.
 * @param aParent {Phaser.Group} The parent Group (or other {@link DisplayObject}) that this group will be added to. If undefined/unspecified the Group will be added to the {@link Phaser.Game#world Game World}; if null the Group will not be added to any parent.
 * @param aName {string} A name for this group. Not used internally but useful for debugging.
 * @param aAddToStage {boolean} If true this group will be added directly to the Game.Stage instead of Game.World.
 * @param aEnableBody {boolean} If true all Sprites created with {@link #create} or {@link #createMulitple} will have a physics body created on them. Change the body type with {@link #physicsBodyType}.
 * @param aPhysicsBodyType {number} The physics body type to use when physics bodies are automatically added. See {@link #physicsBodyType} for values.
 */
function SpaceShip(aGame, aParent, aName, aAddToStage, aEnableBody, aPhysicsBodyType) {
	
	Phaser.Group.call(this, aGame, aParent, aName, aAddToStage, aEnableBody, aPhysicsBodyType);
	
	/* --- post-init-begin --- */
	this.fShipView = this.game.add.sprite(0, 0, "SHIP_MIDDLE_BLUE", null, this);
	this.fShipView.anchor.setTo(0.5, 0.5);
	
	var hpFontStyle = {fontSize: '30px', fill: '#FFD851', boundsAlignH: 'center', boundsAlignV: 'middle'};
	this.fTxtShipHp = this.game.add.text(0, 0, "100", hpFontStyle, this);
	this.fTxtShipHp.anchor.setTo(0.5, 0);
	this.fTxtShipHp.position.setTo(this.fShipView.x, this.fShipView.y + this.fShipView.height / 2);

	// 무기 능력치 
	this.RANGE_GUN = 500;
	
	// 우주선 능력치
	this.ACCELERATION = 20;
	this.BREAKING = 20;
	this.MAX_SPEED = 100; // missile speed pixels/second
	this.TURN_SPEED = 1; // turn rate in degrees/frame
	this.ATTACK_ACCURACY = 80; // percentage of attack success rate
	this.MOVE_ACCURACY = 30;
	this.MAX_HP = 100;
	
	// property
	this.currentSpeed = 0;
	this.currentHp = this.MAX_HP;
	
	this.isFireGun = false;
	this.weaponGun = [];
	
	this.followTarget = null;
	this.enemyList = {};
	
	this.DESTINATION_POINT = null;
	/* --- post-init-end --- */
}

/** @type Phaser.Group */
var SpaceShip_proto = Object.create(Phaser.Group.prototype);
SpaceShip.prototype = SpaceShip_proto;
SpaceShip.prototype.constructor = SpaceShip;

/* --- end generated code --- */
// -- user code here --

SpaceShip.prototype.render = function() {
	//this.game.debug.spriteInfo(this.rangeGun, 32, 32);
	//this.weaponGunBullet.debug();
};

/**
 * 우주선의 색상, 크기를 지정
 * @param inShipColor
 * @param inShipSize 
 */
SpaceShip.prototype.initShip = function(inShipColor, inShipSize) {
	var shipSize = inShipSize;
	this.weaponGun = [];
	if (shipSize === EShipSize.MIDDLE) {
		this.ACCELERATION = 0.5;
		this.BREAKING = 0.5;
		this.MAX_SPEED = 100;
		this.TURN_SPEED = 0.2;
		this.MAX_HP = 200;
	} else if (shipSize === EShipSize.SMALL){
		this.ACCELERATION = 3;
		this.BREAKING = 3;
		this.MAX_SPEED = 300;
		this.TURN_SPEED = 1.0;
		this.MAX_HP = 100;
	} else {
		this.fShipView.scale.setTo(2, 2);
		this.ACCELERATION = 0.3;
		this.BREAKING = 0.3;
		this.MAX_SPEED = 80;
		this.TURN_SPEED = 0.1;
		this.MAX_HP = 500;
	}
	
	// 텍스쳐 업데이트 
	var targetFrameName = StzUtil.strFormat("SHIP_{0}_{1}", shipSize, inShipColor);
	this.fShipView.loadTexture(targetFrameName);
	
	// 프로퍼티 업데이트
	this.currentHp = this.MAX_HP;
	
	// 물리 설정 
	this.game.physics.p2.enable(this.fShipView, false);
	this.getBody().data.shapes[0].name = "body_ship";
	this.getBody().data.shapes[0].sensor = true;
	
	if (shipSize === EShipSize.MIDDLE) {
		var wGun = this.game.add.autoGun(30, StzUtil.strFormat("BULLET_{0}", inShipColor), null, this);
		wGun.trackSprite(this.getBody(), this.width / 2, -this.height / 3, true);
		this.weaponGun.push(wGun);
		var wGun1 = this.game.add.autoGun(30, StzUtil.strFormat("BULLET_{0}", inShipColor), null, this);
		wGun1.trackSprite(this.getBody(), this.width / 2, this.height / 3, true);
		this.weaponGun.push(wGun1);
	} else if (shipSize === EShipSize.SMALL){
		var wGun3 = this.game.add.autoGun(30, StzUtil.strFormat("BULLET_{0}", inShipColor), null, this);
		wGun3.trackSprite(this.getBody(), this.width / 2, 0, true);
		this.weaponGun.push(wGun3);
	} else {
		var wGun4 = this.game.add.autoGun(30, StzUtil.strFormat("BULLET_{0}", inShipColor), null, this);
		wGun4.trackSprite(this.getBody(), this.width / 2, 0, true);
		var wGun5 = this.game.add.autoGun(30, StzUtil.strFormat("BULLET_{0}", inShipColor), null, this);
		wGun5.trackSprite(this.getBody(), this.width / 2, -this.height / 3, true);
		var wGun6 = this.game.add.autoGun(30, StzUtil.strFormat("BULLET_{0}", inShipColor), null, this);
		wGun6.trackSprite(this.getBody(), this.width / 2, this.height / 3, true);
		this.weaponGun.push(wGun4);
		this.weaponGun.push(wGun5);
		this.weaponGun.push(wGun6);
	}
	
	
	// 건 사거리 센서 설정 
	this.gunSensor = this.getBody().addRectangle(this.RANGE_GUN, this.getView().height, this.getView().width / 2 + this.RANGE_GUN / 2, 0);
	this.gunSensor.name = "sensor_gun";
	this.gunSensor.sensor = true;
	this.getBody().onBeginContact.add(this.onBeginContactEnemy, this);
	this.getBody().onEndContact.add(this.onEndContactEnemy, this);
};

/**
 * 트리거 발동 
 */
SpaceShip.prototype.onBeginContactEnemy = function(inOtherBody, inOtherBodyData, inMyShape, inOtherShape, inEquation) {
	if (inMyShape.name === "sensor_gun" && inOtherShape.name === "body_ship") {
		this.isFireGun = true;
	}
	
	if (inOtherShape.name === "bullet" && inMyShape.name === "body_ship") {
		if (inOtherBody.parentGroup !== this) {
			this.currentHp--;
		}
	} 
};

/**
 * 트리거 해제 
 * @param inOtherBody
 * @param inOtherBodyData
 * @param inMyShape
 * @param inOtherShape
 * @param inEquation
 */
SpaceShip.prototype.onEndContactEnemy = function(inOtherBody, inOtherBodyData, inMyShape, inOtherShape, inEquation) {
	if (inMyShape.name === "sensor_gun" && inOtherShape.name === "body_ship") {
		this.isFireGun = false;
	}
};

/**
 * 뷰 스프라이트 객체 획득 
 * @returns 
 */
SpaceShip.prototype.getView = function() {
	return this.fShipView;
};

/**
 * 바디 충돌체 객체 획득 
 * @returns
 */
SpaceShip.prototype.getBody = function() {
	return this.getView().body;
};

/**
 * 적 우주선 등록 
 * @param inShip
 * @returns {Boolean}
 */
SpaceShip.prototype.addEnemy = function(inShip) {
	if (!inShip.getBody()) {
		return false;
	}
	this.enemyList[inShip.getBody().data.id] = inShip;
	return true;
};

/**
 * 우주선이 자동으로 쫓아다닐 타겟 지정 - 
 * @param inShip
 * @returns {Boolean}
 */
SpaceShip.prototype.setFollowTarget = function(inShip) {
	if (!inShip.getBody()) {
		return false;
	}
	this.followTarget = inShip;
	return true;
};

/**
 * 우주선의 위치를 즉각적으로 이동 
 * @param inX
 * @param inY
 */
SpaceShip.prototype.setPosition = function(inX, inY) {
	this.fShipView.body.x = inX;
	this.fShipView.body.y = inY;
	this.fShipView.body.setZeroVelocity();
};

/**
 * 우주선이 이동할 위치를 지정
 * @param inPosition {Phaser.Position} 
 */
SpaceShip.prototype.setDestinationPoint = function(inPosition) {
	this.DESTINATION_POINT = {};
	this.DESTINATION_POINT.x = inPosition.x;
	this.DESTINATION_POINT.y = inPosition.y;
};

/**
 * 우주선 체력 텍스트가 우주선을 따라다니도록 업데이트 - update에서 호출 
 */
SpaceShip.prototype.updateHpText = function() {
	this.fTxtShipHp.text = this.currentHp;
	this.fTxtShipHp.position.setTo(this.getBody().x, this.getBody().y + this.getView().height / 2);
};

/**
 * 우주선 프레임 업데이트 함수 
 */
SpaceShip.prototype.update = function() {
	this.updateHpText();
	if (this.isFireGun) {
		
		for (var i = 0; i < this.weaponGun.length; i++) {
			var bullet = this.weaponGun[i].fire(this.getBody());
			if (bullet) {
				bullet.body.parentGroup = this;
				bullet.lifespan = 1000;
			}
		}
 	}
	
	if (this.followTarget) {
		this.setDestinationPoint(this.followTarget.getBody());
	}
	
	if (this.DESTINATION_POINT == null) {
		if (this.currentSpeed <= 0) {
			this.currentSpeed = 0;	
		} else {
			this.currentSpeed -= this.BREAKING;
		}
		
	} else {
		if (this.followTarget) {
			this.MOVE_ACCURACY = 200;
		}
		var distance = this.game.math.distance(this.fShipView.body.x, this.fShipView.body.y, this.DESTINATION_POINT.x, this.DESTINATION_POINT.y);
        if (distance < this.MOVE_ACCURACY) {
	        	this.DESTINATION_POINT = null;
	        	return;
        }
        
		var targetAngle = this.game.math.angleBetween(this.fShipView.body.x, this.fShipView.body.y, this.DESTINATION_POINT.x, this.DESTINATION_POINT.y);
		if (this.fShipView.rotation != targetAngle) {
			// Calculate difference between the current angle and targetAngle
	        var delta = targetAngle - this.fShipView.body.rotation;
	        
	        // Keep it in range from -180 to 180 to make the most efficient turns.
	        if (delta > Math.PI) delta -= Math.PI * 2;
	        if (delta < -Math.PI) delta += Math.PI * 2;

	     // Just set angle to target angle if they are close
	        if (Math.abs(delta) < this.game.math.degToRad(this.TURN_SPEED)) {
	        	this.fShipView.body.setZeroRotation();
	        } else if (delta > 0) {
	            // Turn clockwise
	        	this.getView().body.angle += this.TURN_SPEED;
	        } else {
	            // Turn counter-clockwise
	        	this.getView().body.angle -= this.TURN_SPEED;
	        }
		 }
		// Calculate velocity vector based on this.rotation and this.MAX_SPEED
		if (this.currentSpeed >= this.MAX_SPEED) {
			this.currentSpeed = this.MAX_SPEED;
		} else {
			this.currentSpeed += this.ACCELERATION;
		}
	}
	//console.log(StzUtil.strFormat("[SPACESHIP] currentSpeed: {0}", this.currentSpeed));
	this.fShipView.body.velocity.x = Math.cos(this.fShipView.body.rotation) * this.currentSpeed;
	this.fShipView.body.velocity.y = Math.sin(this.fShipView.body.rotation) * this.currentSpeed;
	//this.position.setTo(this.getBody().x, this.getBody.y);
	// 공격
};

var EShipSize = {
	BIG: "BIG", 
	MIDDLE: "MIDDLE", 
	SMALL: "SMALL"
};

var EShipColor = {
	BLUE: "BLUE", 
	YELLOW: "YELLOW", 
	RED: "RED"
};
